scalar Object
scalar ServiceURI
scalar NodeType
scalar Url
scalar Boolean
scalar Long

type ServiceRef {
    serviceUri: ServiceURI!
    alias: String
    labels: Object!
    annotations: Annotations!
}

type Annotations {
    platform: Object!
    cryostat: Object!
}

type TargetNode implements Node {
    target: ServiceRef!
    recordings: Recordings!

    name: String!
    nodeType: NodeType!
    labels: Object!

    startRecording(recording: RecordingSettings!): ActiveRecording!
    # snapshot: ActiveRecording!
    # TODO the below queries should actually belong to ActiveRecording and mutate the recording as the source
    stopRecordings(names: [String!]): [ActiveRecording!]
    deleteRecordings(names: [String!]): [ActiveRecording!]
    # archiveRecordings(names: [String!]): [ArchivedRecording!]
}

type EnvironmentNode implements Node {
    children: [Node!]!

    name: String!
    nodeType: NodeType!
    labels: Object!

    descendantTargets: [TargetNode!]! # TODO add some kind of filters
}

input EnvironmentNodeFilterInput {
    nodeName: String
    nodeType: String
    labelKey: String
    labelValue: String
}

interface Node {
    name: String!
    nodeType: NodeType!
    labels: Object!
}

type Recordings {
    active(names: [String!]): [ActiveRecording!]!
    archived(names: [String!]): [ArchivedRecording!]!
}

type ActiveRecording implements Recording {
    state: String!
    startTime: Long!

    duration: Long!
    continuous: Boolean!
    toDisk: Boolean!
    maxSize: Long!
    maxAge: Long!

    name: String!
    reportUrl: Url!
    downloadUrl: Url!
}

type ArchivedRecording implements Recording {
    name: String!
    reportUrl: Url!
    downloadUrl: Url!
}

interface Recording {
    name: String!
    reportUrl: Url!
    downloadUrl: Url!
}

input RecordingSettings {
    name: String!
    template: String!
    templateType: String!
    duration: Long
    continuous: Boolean
    toDisk: Boolean
    maxSize: Long
    maxAge: Long
}
